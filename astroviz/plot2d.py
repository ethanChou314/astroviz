from .common import *


class Plot2D:
    """
    A class for handling two-dimensional plots such as SED plots, 
    spectral/spatial profiles, and intensity distribution diagrams.
    """
    def __init__(self, file=None, x=None, y=None, xerr=None, yerr=None,
                 header=None, bins=None, xlabel=None, xunit=None, 
                 ylabel=None, yunit=None, pandas=False, delimiter=None, 
                 xloc=None, yloc=None, comment="#", pd_header=None, 
                 scale="linear", quiet=False, **kwargs):
        """
        Constructor that initializes the Plot2D object with the provided data and parameters.

        Parameters:
        - file (str, optional): Path to the file containing data.
        - x (array-like, optional): Data for the x-axis.
        - y (array-like, optional): Data for the y-axis.
        - xerr (array-like, optional): Error bars for the x-axis.
        - yerr (array-like, optional): Error bars for the y-axis.
        - header (dict, optional): Dictionary containing header information.
        - bins (int or sequence, optional): Number of bins or bin edges for histograms.
        - xlabel (str, optional): Label for the x-axis.
        - xunit (str or astropy.units.Unit, optional): Unit for the x-axis data.
        - ylabel (str, optional): Label for the y-axis.
        - yunit (str or astropy.units.Unit, optional): Unit for the y-axis data.
        - pandas (bool, optional): Whether to use pandas for file reading.
        - delimiter (str, optional): Delimiter for reading the file.
        - xloc (int, optional): Column index for x data in the file.
        - yloc (int, optional): Column index for y data in the file.
        - comment (str, optional): Character used to indicate the start of a comment in the file.
        - pd_header (int, optional): Row number to use as the header (and column names) for pandas.
        - scale (str or tuple, optional): Scale type for the axes ('linear' or 'log').
        - **kwargs: Additional keyword arguments to be passed to the file reading function.

        Raises:
        - Exception: If no file, x, or y data is provided.
        - ValueError: If x or y is 0-sized.
        """
        
        # if nothing is specified, raise Exception
        if all(var is None for var in (file, x, y)):
            raise Exception("Please specify the file, x, and/or y.")
            
        # read file, if any
        if file:
            read_file_results = self.__read_file(file=file, 
                                                 pandas=pandas, 
                                                 delimiter=delimiter, 
                                                 xloc=xloc, 
                                                 yloc=yloc, 
                                                 comment=comment, 
                                                 header=pd_header, 
                                                 quiet=quiet,
                                                 **kwargs)
            xdata,  ydata, xlabel, ylabel, xunit, yunit = read_file_results
            x = xdata
        
        # initialize header
        init_header = {"filepath": "" if file is None else file,
                       "imagetype": "Plot2D",
                       "size": x.size,
                       "xlabel": "" if xlabel is None else xlabel,
                       "xunit": "" if not xunit else _apu_to_headerstr(_to_apu(xunit)),
                       "ylabel": "Counts" if ylabel is None else ylabel,
                       "yunit": "" if not yunit else _apu_to_headerstr(_to_apu(yunit)),
                       "scale": (scale.lower(), scale.lower()) if isinstance(scale, str) else scale,
                       "date": str(dt.datetime.now()).replace(" ", "T"),
                       "origin": "Generated by Astroviz."}
        
        immutable_keys = ("imagetype", "size")
        if header is not None and isinstance(header, dict):
            for key, value in header.items():
                if key in init_header:
                    if key in immutable_keys and header[key] != init_header[key]:
                        print(f"'{key}' is an immutable header parameter " + \
                               "and cannot be modified.")
                    else:
                        init_header[key] = value
                else:
                    print(f"'{key}' is not a valid header parameter" + \
                          " and will be ignored.")
                
        self.header = init_header
        
        # initialize x values
        if not isinstance(x, np.ndarray):
            x = np.array(x)
        if x.size < 1:
            raise ValueError("x should not be 0-sized.")
        if x.ndim > 1:
            warnings.warn("x is not 1-dimensional and will be flattened.")
            x = x.flatten()
        
        # convert into frequency graph if y is not provided
        if y is None:
            self.histogram = True
            if bins is None:
                bins = "auto"
            self.y, self.bins = np.histogram(x, bins=bins)
            self.yaxis = self.y
            self.data = x
            self.xaxis = self.x = (self.bins[:-1] + self.bins[1:]) / 2  # set midpoints as x
        else:
            self.histogram = False
            # if provided, initialize y values
            if not isinstance(y, np.ndarray):
                y = np.array(y)
            if y.size < 1:
                raise ValueError("y should not be 0-sized.")
            if y.ndim > 1:
                warnings.warn("y is not 1-dimensional and will be flattened.")
                y = y.flatten()
            
            # sort by x if x is not sorted
            if np.all(x[:-1] <= x[1:]):  # check if numpy array is sorted
                sort_idx = np.argsort(x)
                x = x[sort_idx]
                y = y[sort_idx]
            
            # assign attributes
            self.x = self.xaxis = x
            self.y = self.yaxis = y
            self.data = (x, y)

        # parse error bars
        if xerr is not None:
            xerr = np.array(xerr)  # convert to numpy array
            if xerr.size != self.x.size:
                raise ValueError("Length of 'xerr' is different from length of 'x'.")
        if yerr is not None:
            yerr = np.array(yerr)  # convert to numpy array
            if yerr.size != self.y.size:
                raise ValueError("Length of 'yerr' is different from length of 'y'.")

        self.xerr = xerr  # set as attributes
        self.yerr = yerr

        if self.x.size != self.y.size:
            raise ValueError("Length of x is different from length of y.")
        
        # match attributes with header information
        self.__updateparams()
        
    def __updateparams(self):
        self.filepath = self.header["filepath"]
        self.size = self.header["size"]
        self.xunit = self.header["xunit"]
        self.xlabel = self.header["xlabel"]
        self.yunit = self.header["yunit"]
        self.ylabel = self.header["ylabel"]
        self.scale = self.header["scale"]
            
    def __len__(self):
        return self.size

    def max(self, axis="y"):
        """
        Public method to compute the maximum value along a specified axis.
        ------
        Parameters:
            axis (str): The axis along which to compute the maximum value.
                        It should be either 'x' or 'y' and is case-insensitive.
                        Default is 'y'.
        Returns:
            float: The maximum value along the specified axis, ignoring any NaN values.
        
        Raises:
            ValueError: If the provided axis is not 'x' or 'y'.
        """
        axis = axis.lower()  # make it case-insensitive
        if axis == "y":
            return np.nanmax(self.y)
        elif axis == "x":
            return np.nanmax(self.x)
        raise ValueError(f"Invalid axis '{axis}'. Expected 'x' or 'y'.")

    def min(self, axis="y"):
        """
        Public method to compute the minimum value along a specified axis.
        ------
        Parameters:
            axis (str): The axis along which to compute the maximum value.
                        It should be either 'x' or 'y' and is case-insensitive.
                        Default is 'y'.
        Returns:
            float: The minimum value along the specified axis, ignoring any NaN values.
        
        Raises:
            ValueError: If the provided axis is not 'x' or 'y'.
        """
        axis = axis.lower()
        if axis == "y":
            return np.nanmin(self.y)
        elif axis == "x":
            return np.nanmax(self.x)
        raise ValueError(f"Invalid axis '{axis}'. Expected 'x' or 'y'.")

    def copy(self):
        """
        This method creates a copy of the original image.
        """
        return copy.deepcopy(self)
    
    def concatenate(self, plot, equivalencies=None, inplace=False):
        """
        Public method to concatenate two datasets.
        ------
        Parameters:
            plot (Plot2D): plot to be concatenated
        Returns:
            concat_plot (Plot2D): plot that is the concatenation of two datasets.
        """
        concat_plot = self if inplace else self.copy()
        
        # check if the units of the plots are the same
        if self.xunit != plot.xunit:
            # try to convert the units
            if _to_apu(self.xunit).is_equivalent(_to_apu(plot.xunit), equivalencies=equivalencies):
                plot = plot.conv_xunit(self.xunit, equivalencies=equivalencies, inplace=False)
            else:
                # if that doesn't work, raise an error
                raise UnitConversionError("The x units of the two plots are not equivalent.")
            
        if self.yunit != plot.yunit:
            # try to convert the units
            if _to_apu(self.yunit).is_equivalent(_to_apu(plot.yunit), equivalencies=equivalencies):
                plot = plot.conv_yunit(self.yunit, equivalencies=equivalencies, inplace=False)
            else:
                # if that doesn't work, raise an error
                raise UnitConversionError("The y units of the two plots are not equivalent.")
            
        # add the axes if the units are the same
        new_x = np.concatenate(self.x, plot.x)
        new_y = np.concatenate(self.y, plot.y)
        
        # sort based on x
        xidx = np.argsort(new_x)
        new_x = new_x[xidx]
        new_y = new_y[xidx]
        
        # assign to new data
        concat_plot.x = new_x
        concat_plot.y = new_y
        
        return concat_plot
        
    def conv_xunit(self, xunit, equivalencies=None, inplace=True):
        """
        Public method to convert the unit of the x data.
        ------
        Parameters:
            xunit (str): the new unit
            equivalencies (astropy.units.equivalencies): equivalencies needed
        Returns:
            image (Plot2D): the plot with the units converted
        """
        image = self if inplace else self.copy()
        current_xunit = 1 * _to_apu(image.xunit)
        new_xunit = 1 * _to_apu(xunit)
        conversion_factor = current_xunit.to_value(new_xunit, equivalencies=equivalencies)
        image.x *= conversion_factor
        image.header["xunit"] = _apu_to_headerstr(new_xunit.unit)
        image.__updateparams()
        return image
    
    def conv_yunit(self, yunit, equivalencies=None, inplace=True):
        """
        Public method to convert the unit of the y data.
        ------
        Parameters:
            yunit (str): the new unit
            equivalencies (astropy.units.equivalencies): equivalencies needed
        Returns:
            image (Plot2D): the image with the units converted
        """
        image = self if inplace else self.copy()
        current_yunit = 1 * _to_apu(image.yunit)
        new_yunit = 1 * _to_apu(yunit)
        conversion_factor = current_xunit.to_value(new_yunit, equivalencies=equivalencies)
        image.y *= conversion_factor
        image.header["yunit"] = _apu_to_headerstr(new_yunit.unit)
        image.__updateparams()
        return image
    
    def set_xlabel(self, xlabel, inplace=True):
        image = self if inplace else self.copy()
        image.header["xlabel"] = xlabel
        image.__updateparams()
        return image
    
    def set_ylabel(self, ylabel, inplace=True):
        image = self if inplace else self.copy()
        image.header["ylabel"] = ylabel
        image.__updateparams()
        return image
    
    def set_xunit(self, xunit, inplace=True):
        image = self if inplace else self.copy()
        xunit = _apu_to_headerstr(_to_apu(xunit))
        image.header["xunit"] = xunit
        image.__updateparams()
        return image
    
    def set_yunit(self, yunit, inplace=True):
        image = self if inplace else self.copy()
        yunit = _apu_to_headerstr(_to_apu(yunit))
        image.header["yunit"] = yunit
        image.__updateparams()
        return image
    
    def stats_1d(self) -> None:
        """
        View the relevant 1D statistics of the data.
        """
        # remove nan values
        mask = (~np.isnan(self.x)) & (~np.isnan(self.y))
        xdata = self.x[mask]
        ydata = self.y[mask]
        
        # x-axis
        x_mean = np.mean(xdata)
        x_std = np.std(xdata)
        x_max = np.max(xdata)
        x_min = np.min(xdata)
        
        # y-axis
        y_mean = np.mean(ydata)
        y_std = np.std(ydata)
        y_max = np.max(ydata)
        y_min = np.min(ydata)
        
        # print values
        print("1D Statistics".center(25, "#"))
        print("X-axis")
        if self.xunit:
            print(f"Mean: {x_mean:.4f} [{self.xunit}]")
            print(f"SD: {x_std:.4f} [{self.xunit}]")
            print(f"Min: {x_min:.4f} [{self.xunit}]")
            print(f"Max: {x_max:.4f} [{self.xunit}]")
        else:
            print(f"Mean: {x_mean:.4f}")
            print(f"SD: {x_std:.4f}")
            print(f"Min: {x_min:.4f}")
            print(f"Max: {x_max:.4f}")
        print()  # skip a line
        
        print("Y-axis")
        if self.yunit:
            print(f"Mean: {y_mean:.4f} [{self.yunit}]")
            print(f"SD: {y_std:.4f} [{self.yunit}]")
            print(f"Min: {y_min:.4f} [{self.yunit}]")
            print(f"Max: {y_max:.4f} [{self.yunit}]")
        else:
            print(f"Mean: {y_mean:.4f}")
            print(f"SD: {y_std:.4f}")
            print(f"Min: {y_min:.4f}")
            print(f"Max: {y_max:.4f}")
        print(25*"#")
        
    def linear(self, x=True, y=True, inplace=True):
        """
        Convert the scale of the image from log to linear.
        ------
        Parameters:
            x (bool): True to convert the xaxis to linear scale
            y (bool): True to convert the yaxis to linear scale
            inplace (bool): True to modify the object in-place. False to return a new object.
        Returns:
            image (Plot2D): the new plot with scales converted.
        """
        image = self if inplace else self.copy()
        
        if x:
            if image.header["scale"][0] == "log":
                image.x = 10**(image.x)
                image.header["scale"] = ("linear", image.header["scale"][1])
            elif image.header["scale"][0] == "linear":
                warnings.warn("the x-axis of the plot is already in " + \
                      "linear scale and will not be converted.")
        if y:
            if image.header["scale"][1] == "log":
                image.y = 10**(image.y)
                image.header["scale"] = (image.header["scale"][0], "linear")
            elif image.header["scale"][1] == "linear":
                warnings.warn("the y-axis of the plot is already in linear scale " + \
                      "and will not be converted.")
        
        # update parameters to match header
        image.__updateparams()
        
        return image
        
    def logscale(self, x=True, y=True, inplace=True):
        """
        Convert the scale of the image from linear to log.
        ------
        Parameters:
            x (bool): True to convert the xaxis to log scale
            y (bool): True to convert the yaxis to log scale
            inplace (bool): True to modify the object in-place. False to return a new object.
        Returns:
            image (Plot2D): the new plot with scales converted
        """
        image = self if inplace else self.copy()
        
        if x:
            if image.header["scale"][0] == "linear":
                image.x = np.log10(image.x)
                image.header["scale"] = ("log", image.header["scale"][1])
            elif image.header["scale"][0] == "log":
                warnings.warn("the x-axis of the plot is already in log scale and will not be converted.")
        if y:
            if image.header["scale"][1] == "linear":
                image.y = np.log10(image.y)
                image.header["scale"] = (image.header["scale"][0], "log")
            elif image.header["scale"][1] == "log":
                warnings.warn("the y-axis of the plot is already in log scale and will not be converted.")
        
        # update parameters to match header
        image.__updateparams()
        
        return image
    
    def set_threshold(self, threshold, inplace=True):
        """
        Public method to remove data points with y values that lie 
        below the given threshold.
        threshold (float): the threshold
        inplace (bool): True to modify the plot in-place. 
                        False to return a new plot.
        """
        image = self if inplace else self.copy()
        mask = image.y > threshold
        image.y = image.y[mask]
        image.x = image.x[mask]
        return image
        
    def trim(self, xlim=None, ylim=None, exclude=False, inplace=False):
        """
        Private method to trim the data. 
        Parameters:
            xlim (list[float, ...] | list[list[float, float], ...]): range of x values
            ylim (list[float, ...] | list[list[float, float], ...]): range of y values
            exclude (bool): True to exclude specified ranges. False to include.
            inplace (bool): True to modify the plot in-place. False to return a new plot.
        Returns:
            image (Plot2D): the trimmed image.
        """
        warnings.warn("The method 'trim' is still in testing.")
        image = self if inplace else self.copy()
        if xlim is None and ylim is None:
            warnings.warn("'xlim' and 'ylim' are not specified." + \
                  "The original image will be returned.")
            return image
        else:
            # convert to numpy arrays
            xlim = np.array(xlim)
            ylim = np.array(ylim)
            
            mask = np.full(image.x.shape, False)  # initialize mask
            if xlim is not None:
                # mask in x direction
                if xlim.ndim == 1 and xlim.size == 2: 
                    mask = mask | ((xlim[0]<=image.x)&(image.x<=xlim[1]))
                elif xlim.ndim == 2:
                    for (x1, x2) in xlim:
                        mask = mask | ((x1<=image.x)&(image.x<=x2))
                else:
                    raise ValueError("Invalid range of x values provided.")
                # mask in y direction
                if ylim.ndim == 1 and ylim.size == 2:
                    mask = mask | ((ylim[0]<=image.y)&(image.y<=ylim[1]))
                elif ylim.ndim == 2:
                    for (y1, y2) in ylim:
                        mask = mask | ((y1<=image.y)&(image.y<=y2))
                else:
                    raise ValueError("Invalid range of y values provided.")
                    
            if exclude:
                mask = ~mask
                
            # trim
            image.x = image.x[mask]
            image.y = image.y[mask]
            
        return image
    
    def __read_file(self, file, pandas=False, delimiter=None, 
                    xloc=None, yloc=None, comment="#", header=None, 
                    quiet=False, **kwargs):
        
        if not os.path.exists(file):
            if not quiet:
                print(f"Given directory '{file}' does not exist as a relative directory. " + \
                       "Recursively finding file...")
            maybe_filename = _find_file(file)
        if maybe_filename is not None:
            file = maybe_filename
            if not quiet:
                print(f"Found a matching filename: '{file}'")
        else:
            raise FileNotFoundError(f"Filename '{file}' does not exist.")
        
        def get_str_between(s: str, start: str, end: str) -> str:
            start_idx: int = s.find(start)
            if start_idx == -1:
                return ""
            start_idx += len(start)
            end_idx = s.rfind(end)
            if end_idx == -1:
                return ""
            return s[start_idx:end_idx]
        
        if pandas:
            xunit = xlabel = yunit = ylabel = ""  # initalize values
            is_spec_profile = False
            with open(file, "r") as f:
                for line in f:
                    lower_line = line.lower()
                    if "spectral profile" in lower_line:
                        is_spec_profile = True
                    if line.startswith("#"):
                        if "xlabel" in lower_line:
                            xunit = get_str_between(line, "[", "]")
                            if is_spec_profile and xunit.lower() == "km/s" \
                               and "radio velocity" in lower_line:
                                xlabel = "radio velocity"
                            else:
                                xlabel = get_str_between(line, ": ", " [")
                        elif "ylabel" in lower_line:
                            yunit = get_str_between(line, "[", "]")
                            if is_spec_profile and yunit.lower() == "kelvin":
                                ylabel = "intensity"
                            else:
                                ylabel = get_str_between(line, ": ", " [")
                    else:
                        break
                    
            df = pd.read_csv(file,
                             delimiter=" " if delimiter is None else delimiter, 
                             comment=comment, 
                             header=header,
                             **kwargs)
            xdata = np.array(df.iloc[:, (0 if xloc is None else xloc)], dtype=float)
            ydata = np.array(df.iloc[:, (1 if yloc is None else yloc)], dtype=float)
        else:
            with open(file, "r") as f:
                lines = np.array(f.readlines())
            lines = np.char.strip(lines, "\n")
            mask = (np.char.find(lines, comment) == -1)
            lines_with_data = lines[mask]
            lines_with_comments = lines[~mask]
            
            if delimiter is None:
                # try different delimiters and see if one of them works!
                delims_to_try = (" ", "\t", ",", ", ", ":", "/")
                for delimiter in delims_to_try:
                    try:
                        lines_with_data = np.char.split(lines_with_data, delimiter)
                        lines_with_data = np.array(lines_with_data.tolist(), dtype=float)
                        xdata = lines_with_data[:, (0 if xloc is None else xloc)]
                        ydata = lines_with_data[:, (1 if yloc is None else yloc)]
                        break  # exit loop if there is no exception
                    except ValueError:
                        continue  # try next delimiter
                else:
                    raise ValueError("None of the delimiters worked " + \
                                     "to split the data correctly.")
            else:
                lines_with_data = np.char.split(lines_with_data, delim)
                lines_with_data = np.array(lines_with_data.tolist(), dtype=float)
                xdata = lines_with_data[:, 0]
                ydata = lines_with_data[:, 1]
            
            xunit = xlabel = yunit = ylabel = ""  # initialize values
            is_spec_profile = False
            for line in lines_with_comments:
                lower_line = line.lower()
                if "spectral profile" in lower_line:
                    is_spec_profile = True
                if line.startswith("#"):
                    if "xlabel" in lower_line:
                        xunit = get_str_between(line, "[", "]")
                        if is_spec_profile and xunit.lower() == "km/s" \
                           and "radio velocity" in lower_line:
                            xlabel = "radio velocity"
                        else:
                            xlabel = get_str_between(line, ": ", " [")
                    elif "ylabel" in lower_line:
                        yunit = get_str_between(line, "[", "]")
                        if is_spec_profile and yunit.lower() == "kelvin":
                            ylabel = "intensity"
                        else:
                            ylabel = get_str_between(line, ": ", " [")
                else:
                    break
        
        return xdata, ydata, xlabel, ylabel, xunit, yunit
    
    def SED(self, distance):
        """
        Derive the bolometric temperature and luminosity from the spectral energy distribution.
        Integration is used rather than fitting.
        Parameters:
            distance (float): distance to the target object
        Returns:
            mean_freq_GHz (float): the intensity-weighted mean frequency in GHz
            Tbol (float): the bolometric 
            Lbol
        """
        # get x, y axes, in order of x axis to correctly integrate
        sort_idx = np.argsort(self.x)
        x = self.x[sort_idx]
        y = self.y[sort_idx]
        
        # parse units
        xunit = _to_apu(self.xunit)
        yunit = _to_apu(self.yunit)
        
        # parse frequency axis
        if xunit.is_equivalent(u.Hz, equivalencies=u.spectral()):
            freq = x * (1*xunit).to_value(u.Hz, equivalencies=u.spectral())
        else:
            raise Exception("Incorrect x-axis unit. " + \
                            "Must be a unit of frequency (e.g., Hz).")
            
        # parse flux axis
        if yunit.is_equivalent(u.Jy):
            flux = y * (1*yunit).to_value(u.Jy)
        elif yunit.is_equivalent(u.Hz*u.Jy, equivalencies=u.spectral()):
            flux = y * (1*yunit).to_value(u.Hz*u.Jy)
            flux /= freq
        else:
            raise Exception("Incorrect y-axis unit. Must be a unit of flux (e.g., Jy).")
            
        # intensity-weighted mean frequency
        int_flux_dfreq = np.trapz(y=flux, x=freq)  # integrate flux wrt freq
        mean_freq = np.trapz(y=freq*flux, x=freq)/int_flux_dfreq  # Hz
        mean_freq_GHz = mean_freq / 1e9
        
        # use mean frequency to calculate bolometric temperature
        Tbol = (1.25e-11 * mean_freq)  # K
        
        # bolometric luminosity
        if isinstance(distance, u.Quantity):
            if not (distance.unit).is_equivalent(u.pc):
                raise Exception("Unit of distance provided is not a " + \
                                "unit of length (e.g., pc).")
        else:
            distance *= u.pc
        Lbol = (4*np.pi*(distance**2) * int_flux_dfreq*u.Jy*u.Hz).to_value(u.Lsun)
        
        # print results
        print("Spectral Energy Distribution".center(40, "#"))
        print(f"Mean frequency: {(mean_freq_GHz):.4f} [GHz]")
        print(f"Tbol: {Tbol:.2f} [K]")
        print(f"Lbol: {Lbol:.2f} [L_sun]")
        print(40*"#", end="\n\n")
        
        return (mean_freq_GHz, Tbol, Lbol)
        
    def fit_SED(self):
        raise Exception("Not implemented yet.")
        
    def imview(self, title=None, xlim=None, ylim=None, legendon=None, legendsize=6,
               legendloc="best", bbox_to_anchor=(0.6, 0.95), xticks=None, yticks=None,
               xlabelon=True, ylabelon=True, linewidth=None, linestyle="-", scale=("linear", "linear"),
               linecolor=None, model_linewidth=None, model_linestyle="-", xlabel=None, ylabel=None, 
               model_linecolor="tomato", ha="center", va="top", textcolor="k",
               threshold=None, fit_xlim=None, fit_ylim=None, figsize=(2.76, 2.76), 
               gauss_fit=False, components=1, p0=None, fixed_values=None, line_fit=False, 
               alternative="two-sided", title_loc=(0.1, 0.875), plot_threshold=True, 
               labelsize=7., curve_fit=None, threshold_color="gray", threshold_ls="dashed",
               threshold_lw=None, fontsize=None, plot_predicted=True, dpi=600, color=None,
               plot_type="line", axeslw=0.7, ticksize=3, labels=["Observation", "Model"], 
               aspect_ratio=1., interpolation=None, linspace_num=10000, residuals_on=True,
               capsize=1., elinewidth=None, fmt='none', marker=".", tick_direction="in",
               ecolor=None, markeredgewidth=None, top_ticks=True, bottom_ticks=True, 
               plot_ebars=None, left_ticks=True, right_ticks=True, savefig=None, 
               linear_ticks=True, with_multiple=False, ax=None, plot=True, **kwargs):
        """
        Plot the 2D data with various customization options.

        Parameters:
        - title (str, optional): Title of the plot.
        - xlim (list or tuple, optional): Limits for the x-axis.
        - ylim (list or tuple, optional): Limits for the y-axis.
        - legendon (bool, optional): Whether to display the legend.
        - legendsize (int, optional): Font size of the legend.
        - legendloc (str, optional): Location of the legend.
        - bbox_to_anchor (tuple, optional): Bounding box anchor for the legend.
        - xticks (list, optional): Tick values for the x-axis.
        - yticks (list, optional): Tick values for the y-axis.
        - xlabelon (bool, optional): Whether to display the x-axis label.
        - ylabelon (bool, optional): Whether to display the y-axis label.
        - linewidth (float, optional): Line width for the data plot.
        - linestyle (str, optional): Line style for the data plot.
        - linecolor (str, optional): Line color for the data plot.
        - model_linewidth (float, optional): Line width for the model plot.
        - model_linestyle (str, optional): Line style for the model plot.
        - model_linecolor (str, optional): Line color for the model plot.
        - ha (str, optional): Horizontal alignment for text.
        - va (str, optional): Vertical alignment for text.
        - textcolor (str, optional): Color for text.
        - threshold (float, optional): Threshold value for a horizontal line.
        - fit_xlim (list or tuple, optional): Limits for fitting on the x-axis.
        - fit_ylim (list or tuple, optional): Limits for fitting on the y-axis.
        - figsize (tuple, optional): Size of the figure.
        - gauss_fit (bool, optional): Whether to perform Gaussian fitting.
        - components (int, optional): Number of components for Gaussian fitting.
        - p0 (list, optional): Initial guess for fitting parameters.
        - fixed_values (dict, optional): Fixed values for fitting parameters.
        - line_fit (bool, optional): Whether to perform linear fitting.
        - alternative (str, optional): Alternative hypothesis for linear fitting.
        - title_loc (tuple, optional): Location for the title.
        - plot_threshold (bool, optional): Whether to plot the threshold line.
        - labelsize (float, optional): Font size for labels.
        - curve_fit (callable, optional): Function for custom curve fitting.
        - threshold_color (str, optional): Color for the threshold line.
        - threshold_ls (str, optional): Line style for the threshold line.
        - threshold_lw (float, optional): Line width for the threshold line.
        - fontsize (float, optional): Font size for the plot text.
        - plot_predicted (bool, optional): Whether to plot predicted values.
        - dpi (int, optional): Dots per inch for the figure.
        - plot_type (str, optional): Type of plot ('line' or 'scatter').
        - borderwidth (float, optional): Width of the plot border.
        - ticksize (float, optional): Size of the plot ticks.
        - labels (list, optional): Labels for the data and model.
        - plot (bool, optional): Whether to display the plot.
        - **kwargs: Additional keyword arguments for plotting.

        Returns:
        - ax (matplotlib.axes.Axes): The axes object of the plot.

        Raises:
        - ValueError: If 'xlim' or 'ylim' have a length greater than 2.
        """
        # get x and y axes
        xdata = self.x
        ydata = self.y
        xerr = self.xerr 
        yerr = self.yerr 

        if plot_ebars is None:
            plot_ebars = not (xerr is None and yerr is None)
        
        # remove bad values
        mask = (~np.isnan(xdata)) & (~np.isnan(ydata)) 
        if not np.all(mask):
            xdata = xdata[mask]
            ydata = ydata[mask]
            if xerr is not None:
                xerr = xerr[mask]
            if yerr is not None:
                yerr = yerr[mask]
            
        # initialize fontsize
        if fontsize is None:
            fontsize = labelsize

        if linewidth is None:
            linewidth = axeslw
        
        if threshold_lw is None:
            threshold_lw = linewidth

        if elinewidth is None:
            elinewidth = linewidth

        if model_linewidth is None:
            model_linewidth = linewidth

        if linecolor is None:
            if interpolation:
                linecolor = "cornflowerblue"
            else:
                linecolor = "k"

        if plot_ebars and ecolor is None:
            if color is None:
                ecolor = linecolor
            else:
                ecolor = color 
        if color is None:
            color = linecolor
            
        # set image parameters
        if ax is None:
            params = {'axes.labelsize': labelsize,
                      'axes.titlesize': labelsize,
                      'font.size': fontsize,
                      'figure.dpi': dpi,
                      'legend.fontsize': legendsize,
                      'xtick.labelsize': labelsize,
                      'ytick.labelsize': labelsize,
                      'font.family': _fontfamily,
                      "mathtext.fontset": _mathtext_fontset,
                      'mathtext.tt': _mathtext_tt,
                      'axes.linewidth': axeslw,
                      'xtick.major.width': axeslw,
                      'ytick.major.width': axeslw,
                      'figure.figsize': figsize,
                      'xtick.major.size': ticksize,
                      'ytick.major.size': ticksize,
                      }
            rcParams.update(params)
            
        # initialize xlim and ylim
        if not with_multiple:
            if xlim is None:
                xmin = np.nanmin(xdata)
                xmax = np.nanmax(xdata)
                xrange = xmax - xmin
                xlim = [xmin-0.1*xrange, xmax+0.1*xrange]
            elif len(xlim) > 2:
                raise ValueError("'xlim' cannot have a length greater than 2.")
            elif xlim[0] > xlim[1]:  # swap if xlim is invalid
                warnings.warn("'xlim' is not correctly specified. Swapping...")
                if isinstance(xlim, tuple):
                    xlim = list(xlim)
                xlim[0], xlim[1] = xlim[1], xlim[0]
                
            if ylim is None:
                ymin = np.nanmin(ydata)
                ymax = np.nanmax(ydata)
                yrange = ymax - ymin
                ylim = [ymin-0.1*yrange, ydata.max()+0.1*yrange]
            elif len(xlim) > 2:
                raise ValueError("'xlim' cannot have a length greater than 2.")
            elif ylim[0] > ylim[1]:  # swap if ylim is invalid
                warnings.warn("'ylim' is not correctly specified. Swapping...")
                if isinstance(ylim, tuple):
                    ylim = list(ylim)
                ylim[0], ylim[1] = ylim[1], ylim[0]
        
        if ax is None:
            fig, ax = plt.subplots(nrows=1, ncols=1, sharex=False, sharey=False)

        # interpolation:
        if isinstance(interpolation, str):
            if not interpolation.islower():
                interpolation = interpolation.lower()  # make it case-insensitive

            if interpolation in ("linear", "nearest", "nearest-up", "zero", "slinear", 
                               "quartic", "cubic", "previous", "next"):
                # create callable
                func: Callable = interpolate.interp1d(x=xdata, y=ydata, kind=interpolation)
                x_interp = np.linspace(xdata.min(), xdata.max(), linspace_num)
                y_interp = func(x_interp)

            else:
                raise ValueError(f"Invalid interpolation method: {interpolation}. Must be one of 'linear', 'nearest', " + \
                                  "'nearest-up', 'zero', 'slinear', 'quartic', 'cubic', 'previous', or 'next'.")
        else:
            # do nothing if user does not wish to interpolate data:
            x_interp = xdata
            y_interp = ydata

        # parse plot type -> make it case-insensitive
        if not plot_type.islower():  
            plot_type = plot_type.lower()

        # start plotting data
        ax = _customizable_scale(ax=ax, xdata=x_interp, ydata=y_interp,
                                 scale=scale, xticks=xticks, yticks=yticks,
                                 plot_type=plot_type, linewidth=linewidth,
                                 linestyle=linestyle, linecolor=linecolor,
                                 label=labels[0], marker=marker, color=color,
                                 plot_ebars=plot_ebars, linear_ticks=linear_ticks, 
                                 **kwargs)
        
        # plot error bars
        if xerr is not None or yerr is not None:
            if markeredgewidth is None:
                markeredgewidth = elinewidth
            ax.errorbar(x=xdata, y=ydata, xerr=xerr, yerr=yerr, 
                        fmt=fmt, marker=marker, ecolor=ecolor, elinewidth=elinewidth, 
                        capsize=capsize, markeredgewidth=markeredgewidth, 
                        label=labels[0])

        # set labels
        if xlabelon:
            if xlabel:
                ax.set_xlabel(xlabel, fontsize=fontsize)
            elif self.xlabel:
                xlabel = self.xlabel.title()
                if self.xunit:
                    xunit = _unit_plt_str(_apu_to_str(_to_apu(self.xunit)))
                    xlabel += " (" + xunit +")" 
                ax.set_xlabel(xlabel, fontsize=fontsize)
        
        if ylabelon:
            if ylabel:
                ax.set_ylabel(ylabel, fontsize=fontsize)
            elif self.ylabel:
                ylabel = self.ylabel.title()
                if self.yunit:
                    yunit = _unit_plt_str(_apu_to_str(_to_apu(self.yunit)))
                    ylabel += " (" + yunit +")" 
                ax.set_ylabel(ylabel, fontsize=fontsize)
            
        # plot threshold as horizontal line
        if plot_threshold and threshold is not None:
            ax.axhline(y=threshold, color=threshold_color, ls=threshold_ls, lw=threshold_lw)
        
        # perform fitting if needed
        if threshold is not None:
            if fit_ylim is None:
                fit_ylim = [ydata.min()-np.std(ydata), threshold]
            else:
                warnings.warn("'threshold' and 'fit_ylim' parameters were both given. " + \
                              "Only 'fit_ylim' will be effective.")
        
        if (gauss_fit or line_fit or curve_fit):
            if gauss_fit:
                # do Gaussian fitting
                popt, perr, func = self.gauss_fit(fit_xlim=fit_xlim, 
                                                  fit_ylim=fit_ylim, 
                                                  components=components, 
                                                  p0=p0, 
                                                  fixed_values=fixed_values)
            elif line_fit:
                popt, perr = self.linear_regression(alternative=alternative)
                func = lambda x, slope, y_int: slope*x + y_int
            elif curve_fit:
                popt, perr = self.curve_fit(function=curve_fit, p0=p0)
                func = curve_fit
                
            # predict and plot model
            smooth_x, predicted_y = self.__predict(popt, func, xlim=None, linspace_num=linspace_num)
            ax.plot(smooth_x, predicted_y, lw=model_linewidth, label=labels[1],
                    ls=model_linestyle, color=model_linecolor)
            
            if legendon is None:  # modify default value
                legendon = True

            # # plot residuals
            # if residuals_on:
            #     raise Exception("Not implemented yet.")
            #     # # calculate residuals
            #     # residuals = ydata - func(xdata, *popt)

            #     # # plot residuals
            #     # height = 
            #     # bbox_to_anchor = ()
            #     # residuals_ax = inset_axes(ax, 
            #     #                           width="100%", 
            #     #                           height=, 
            #     #                           loc="", 
            #     #                           borderpad=0.,
            #     #                           bbox_to_anchor=,
            #     #                           bbox_transform=ax.transAxes)

            
        if legendon is not None and legendon:
            ax.legend(frameon=False, loc=legendloc, bbox_to_anchor=bbox_to_anchor)
            
        # plot title
        if not with_multiple:
            if title is not None:
                # determine location on the xy axes
                xlim_range = xlim[1] - xlim[0]
                ylim_range = ylim[1] - ylim[0]
                title_x = xlim[0] + xlim_range * title_loc[0]
                title_y = ylim[0] + ylim_range * title_loc[1]
                ax.text(title_x, title_y, title, color=textcolor, fontsize=fontsize)
        
            # set xlim and ylim
            ax.set_xlim(xlim)
            ax.set_ylim(ylim)
        
            # tick parameters:
            ax.tick_params(which='both', direction=tick_direction, bottom=bottom_ticks, 
                           top=top_ticks, left=left_ticks, right=right_ticks, 
                           colors="k", labelrotation=0, labelcolor="k", labelsize=labelsize)
            
            # set aspect ratio
            if aspect_ratio:
                horizontal_limit = ax.get_xlim()
                horizontal_range = horizontal_limit[1] - horizontal_limit[0]
                vertical_limit = ax.get_ylim()
                vertical_range = vertical_limit[1] - vertical_limit[0]
                real_aspect_ratio = abs(1./aspect_ratio*horizontal_range/vertical_range)
                ax.set_aspect(real_aspect_ratio)
            
            if savefig:
                plt.savefig(**savefig)

            if plot:
                plt.show()
        
        return ax
    
    def linear_regression(self, alternative="two-sided"):
        """
        Perform a linear regression on the x and y data of the plot.

        Parameters:
        - alternative (str, optional): Defines the alternative hypothesis.
          The default value is "two-sided". Other options are "less" and "greater".

        Returns:
        - output (tuple): A tuple containing two lists:
            - [slope, intercept]: The slope and intercept of the regression line.
            - [slope_err, intercept_err]: The standard error of the slope and intercept.

        Prints:
        - The slope and its error with units.
        - The intercept and its error with units.
        - The correlation coefficient (r) and its square (r^2).
        - The p-value for the hypothesis test.
        """
        result = linregress(x=self.x, y=self.y, alternative=alternative)
        slope = result.slope
        intercept = result.intercept
        rvalue = result.rvalue
        pvalue = result.pvalue
        slope_err = result.stderr
        intercept_err = result.intercept_stderr
        
        print("Linear Regression".center(40, "#"))
        if self.yunit and self.xunit:
            slope_unit = f"[{self.yunit}/{self.xunit}]"
        elif self.yunit:
            slope_unit = f"[{self.yunit}]"
        elif self.xunit:
            slope_unit = f"[1/{self.xunit}]"
        else:
            slope_unit = ""
        print(f"slope: {slope:.4f} +/- {slope_err:.4f} " + slope_unit)
        if self.yunit:
            print(f"intercept: {intercept:.4f} +/- {intercept_err:.4f} [{self.yunit}]")
        else:
            print(f"intercept: {intercept:.4f} +/- {intercept_err:.4f}")
        print(f"r: {rvalue:.4f}")
        print(f"r2: {(rvalue**2):.4f}")
        print(f"p-value ({alternative}): {pvalue:.4f}")
        print(40*"#", end="\n\n")
        
        output = ([slope, intercept], [slope_err, intercept_err])
        return output
    
    def curve_fit(self, function, p0=None, **kwargs):
        """
        Fit the data to a given callable function.
        Parameters:
            function (callable): the function that will be fitted
            p0 (list): a list of parameters to be inputted
            **kwargs: other keyword arguments for 'curve_fit' function of scipy
        Returns:
            popt: the best-fit parameters.
            perr: errors associated with the best-fit parameters.
        """
        mask = (~np.isnan(self.x))&(~np.isnan(self.y))
        
        
        
        # perform fitting based on a function
        try:
            popt, pcov = curve_fit(f=function, xdata=self.x, ydata=self.y, 
                                   p0=p0, **kwargs)
        except:
            print("Failed to fit the given function.")
            return None
        
        # find standard errors of the parameters:
        perr = np.sqrt(np.diag(pcov))
        
        # retreve parameter names by inspecting the callable:
        param_names = tuple(inspect.signature(function).parameters.keys())
        
        # print fitting results:
        print("Fitting Results".center(40, "#"))
        for i, param in enumerate(param_names):
            print(f"{param}: {popt[i]:.4f} +/- {perr[i]:.4f}")
        print(40*"#")
        
        return popt, perr

    def gauss_fit(self, fit_xlim=None, fit_ylim=None, components=1, p0=None, fixed_values=None):
        """
        Public method to fit a Gaussian function to the data.
        --------
        Parameters:
            fit_range (2d array): 
            components (int): number of gaussian components to be fitted
            p0 (list[float]): Initial parameters. 
                              Order is [x, amplitude, fwhm].
                              If there are multiple components, set the initial values to:
                              [[x1, a1, fwhm1], [x2, a2, fwhm2], [x3, a3, fwhm3]], etc.
                              Default is None (guess based on data).
                              If components > 1, default is all ones.
            fixed_values (list[None | float]): Values that will be fixed while fitting.
                                               None to not fix the value.
                                               If there are multiple components, set to:
                                               [[x1, a1, fwhm1], [x2, a2, fwhm2], [x3, a3, fwhm3]], etc.
        Returns:
            popt (list[float]): List of best-fit values.
            pcov (list[float]): SD associated with the best-fit values.
        """
        # remove invalid values while fitting
        mask = (~np.isnan(self.x)) & (~np.isnan(self.y))
        
        # remove values that lie outside the specified ranges
        if fit_xlim is not None:  
            fit_xlim = np.asarray(fit_xlim).flatten()
            xmask = np.array([False]*self.x.size)  # initialize
            for (x1, x2) in zip(fit_xlim[::2], fit_xlim[1::2]):
                xmask = xmask | ((x1<=self.x) & (self.x<=x2))
            mask = mask & xmask

        if fit_ylim is not None:
            fit_ylim = np.asarray(fit_ylim).flatten()
            ymask = np.array([False]*self.y.size)  # initialize
            for (y1, y2) in zip(fit_ylim[::2], fit_ylim[1::2]):
                ymask = ymask | ((y1<=self.y) & (self.y<=y2))
            mask = mask & ymask

        # apply mask
        masked_x = self.x[mask]
        masked_y = self.y[mask]

        # convert to array and reshape
        if fixed_values is not None:
            if not isinstance(fixed_values, np.ndarray):
                fixed_values = np.array(fixed_values, dtype=object)
            if fixed_values.shape != (components, 3):
                fixed_values = fixed_values.reshape((components, 3))
        elif fixed_values is None:
            fixed_values = np.array([[None]*3]*components)
        
        # check whether values are fixed:
        is_fixed = list(list(param is not None for param in comp) \
                        for comp in fixed_values.tolist())
        
        # reassign p0 to a parsable reshape
        if p0 is not None:
            if isinstance(p0, list) and not isinstance(p0[0], list):  # check if p0 is 1d list:
                p0 = [p0]  # convert to 2d list
            elif isinstance(p0, np.ndarray):
                # only acceptable if p0 is 2-dimensional
                if p0.ndim == 1:
                    p0 = p0[np.newaxis, :]
                elif p0.ndim > 2:
                    raise ValueError("p0 should not be more than 2 dimensions.")

            for comp in p0:   # add nan values to p0:
                if len(comp) != 3:
                    comp += [np.nan]*(3-len(comp))

            flattened_p0 = np.array(p0).flatten()  # flatten
            p0 = flattened_p0[~np.isnan(flattened_p0)]
        elif p0 is None and components == 1:
            guess_x0 = np.average(masked_x, weights=masked_y)
            sd_weights = masked_y / np.sum(masked_y)
            guess_std = np.sqrt(np.sum((masked_x - guess_x0)**2 * sd_weights))
            guess_fwhm = guess_std * 2.355  # std -> fwhm
            guess_a = np.max(masked_y)
            p0 = [guess_val for i, guess_val in enumerate((guess_x0, guess_a, guess_fwhm)) \
                  if not is_fixed[0][i]]  # Need to fix this line
            print(f"Initial Guess: {p0}")

        local_namespace = {"np": np}

        # fix values
        for i in range(components):
            params = ("x0", "a", "fwhm")
            valid_params = [param for j, param in enumerate(params) if not is_fixed[i][j]]
            valid_params = ", ".join(valid_params)
            fwhm_in_fn = fixed_values[i][2] if is_fixed[i][2] else 'fwhm'
            amp_in_fn = fixed_values[i][1] if is_fixed[i][1] else 'a'
            center_in_fn = fixed_values[i][0] if is_fixed[i][0] else 'x0'
            exec_code = f"def gauss_component{i+1}(x, {valid_params}): \n"
            exec_code += f"  sigma = {fwhm_in_fn} / 2.355 \n"
            exec_code += f"  return {amp_in_fn}*np.exp(-(x-{center_in_fn})**2/(2*sigma**2))"

            exec(exec_code, local_namespace)

        # define function that is the sum of all gaussian components
        exec_code = f"def gauss(x, "
        for i in range(components):
            params = (f"x0_{i+1}", f"a{i+1}", f"fwhm{i+1}")
            valid_params = [param for j, param in enumerate(params) if not is_fixed[i][j]]
            valid_params = ", ".join(valid_params)
            exec_code += valid_params
            if i != components - 1:
                exec_code += ", "

        exec_code += "): \n"

        for i in range(components):
            if i == 0:
                exec_code += "  return "
            params = (f"x0_{i+1}", f"a{i+1}", f"fwhm{i+1}")
            valid_params = [param for j, param in enumerate(params) if not is_fixed[i][j]]
            valid_params = ", ".join(valid_params)
            exec_code += f"gauss_component{i+1}(x, {valid_params})"
            if i != components - 1:
                exec_code += "+"
        
        exec(exec_code, local_namespace)
        gauss = local_namespace['gauss']
        
        # start fitting gaussian function
        try:
            popt, pcov = curve_fit(f=gauss, xdata=masked_x, ydata=masked_y, p0=p0)
        except:
            print("Fitting failed.")
            return None
        perr = np.sqrt(np.diag(pcov))

        # start printing results
        j = 0  # counter
        print("Gaussian Fitting Results".center(40, "#"))
        for i in range(components):
            print(f"Component {i+1}")
            if not is_fixed[i][0]:
                print(f"Center: {popt[j]:.4f} +/- {perr[j]:.4f}")
                j += 1
            if not is_fixed[i][1]:
                print(f"Amplitude: {popt[j]:.4f} +/- {perr[j]:.4f}")
                j += 1
            if not is_fixed[i][2]:
                print(f"FWHM: {popt[j]:.4f} +/- {perr[j]:.4f}")
                j += 1
            if i != components - 1:  # if i corresponds to the last index
                print()
        print(40*"#", end="\n\n")

        return popt, perr, gauss
    
#     def hf_fit(self, restfreq, components=3):
#         """
#         Perform hyperfine fitting to the spectrum.
#         Parameters:
#             restfreq (float): the rest frequnecy in GHz.
#         """
#         # physical constants
#         clight = const.c.cgs  # speed of light in vacuum
#         h = const.h.cgs  # planck constant
#         k_B = const.k_B.cgs  # Boltzmann's constant
#         T_bg = 2.725*u.K  # cosmic microwave background temperature
        
#         if components == 3:
            
    def __predict(self, popt, func, xlim=None, linspace_num=10000):
        """
        Private function to predict values based on results of fitting.
        (AKA last forward prop)
        ------
        Parameters:
            popt (list[float]): a list of best-fit parameters
            func (callable): function that gives y given x (that can be used ot predict y-values)
            xlim (list[float], optional): The [min, max] values of x.
                                          Default is to set as (min of x - 1 sd, max of x + 1 sd)
                                            
            linspace_num (int): spacing between two x values in y
        Returns:
            smoothx (np.ndarray[float]): array of x values that correspond to the predicted y values
            predicted_y
        """
        if xlim is None:
            masked_x = self.x[~np.isnan(self.x)]  # remove invalid values (nan)
            x_sd = np.std(masked_x)  # standard deviation of x
            xlim = (masked_x.min() - x_sd, masked_x.max() + x_sd)  # default xlim
        smoothx = np.linspace(xlim[0], xlim[1], linspace_num)
        predicted_y = func(smoothx, *popt)
        return (smoothx, predicted_y)
    
#     def __residual(self, smoothx, observed_y, predicted_y):
#         return predicted_y - observed_y
#        
    def export_csv(self, outname, delimiter=",", overwrite=False):  
        """
        Export the plot data to a CSV file.

        Parameters:
        - outname (str): The name of the output CSV file.
        - delimiter (str, optional): The delimiter to use in the CSV file. Default is a comma (",").
        - overwrite (bool, optional): Whether to overwrite the existing file. Default is False.

        Description:
        - Adds the ".csv" extension to the output file name if not already present.
        - If `overwrite` is False, appends "(1)", "(2)", etc., to the file name to avoid overwriting.
        - If `overwrite` is True and the file exists, deletes the existing file.
        - Writes the data to the CSV file with the specified delimiter, including header information.

        Raises:
        - OSError: If there is an issue writing to the file.

        Notes:
        - The CSV file includes metadata such as the export date, x-axis label and unit, and y-axis label and unit.
        """
        # add file name extension if not in user input
        if not outname.endswith(".csv"):
            outname += ".csv"
        
        # if not overwrite, add (1), (2), (3), etc. to file name before '.fits'
        if not overwrite:
            outname = _prevent_overwriting(outname)
        else:
            if os.path.exists(outname):
                os.system(f"rm -rf {outname}")
        
        file_content = "# Exported from Astroviz. \n"
        file_content += f"# Date: {self.header['date']} \n"
        file_content += f"# xLabel: {self.xlabel} [{self.xunit}] \n"
        file_content += f"# yLabel: {self.ylabel} [{self.yunit}] \n"
        file_content += f"# x,y \n"
        data = np.vstack(self.x, self.y).T.astype(str)
        data_lines = np.apply_along_axis(lambda arr: ",".join(arr), 1, data)
        data_lines = "\n".join(data_lines)
        file_content += data_lines
        
        with open(outname, "w") as f:
            f.write(file_content)
        print(f"File saved as '{outname}'.")
